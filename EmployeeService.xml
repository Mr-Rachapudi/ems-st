<?xml version="1.0"?>
<st-source>
<class>
<class-id>EmployeeService</class-id>
<superclass>Object</superclass>
<instance-variables>database createValidator readValidator updateValidator deleteValidator</instance-variables>
<class-variables>Instance</class-variables>
<pool-dictionaries></pool-dictionaries>
<methods>
<body package="EmployeeManagement-Service" selector="initialize">
initialize
    super initialize.
    database := EmployeeDatabase instance.
    createValidator := CreateEmployeeValidator new.
    readValidator := ReadEmployeeValidator new.
    updateValidator := UpdateEmployeeValidator new.
    deleteValidator := DeleteEmployeeValidator new.
</body>
<body package="EmployeeManagement-Service" selector="createEmployee:">
createEmployee: anEmployee
    | errors |
    errors := createValidator validateEmployee: anEmployee.
    errors isEmpty ifFalse: [
        ^self signalValidationError: 'Employee creation failed' errors: errors
    ].
    
    [^database insertEmployee: anEmployee]
        on: Error
        do: [:ex | self signalDatabaseError: 'Failed to create employee' cause: ex]
</body>
<body package="EmployeeManagement-Service" selector="readEmployee:">
readEmployee: anId
    | errors employee |
    errors := readValidator validateEmployeeId: anId.
    errors isEmpty ifFalse: [
        ^self signalValidationError: 'Employee retrieval failed' errors: errors
    ].
    
    [employee := database findEmployeeById: anId]
        on: Error
        do: [:ex | self signalDatabaseError: 'Failed to read employee' cause: ex].
    
    employee ifNil: [
        self signalNotFoundError: 'Employee with ID ', anId printString, ' not found'
    ].
    
    ^employee
</body>
<body package="EmployeeManagement-Service" selector="readAllEmployees">
readAllEmployees
    [^database findAllEmployees]
        on: Error
        do: [:ex | self signalDatabaseError: 'Failed to read employees' cause: ex]
</body>
<body package="EmployeeManagement-Service" selector="updateEmployee:">
updateEmployee: anEmployee
    | errors existingEmployee |
    errors := updateValidator validateEmployeeForUpdate: anEmployee.
    errors isEmpty ifFalse: [
        ^self signalValidationError: 'Employee update failed' errors: errors
    ].
    
    existingEmployee := self readEmployee: anEmployee id.
    
    errors := updateValidator validateSalaryIncrease: existingEmployee salary newSalary: anEmployee salary.
    errors isEmpty ifFalse: [
        ^self signalValidationError: 'Salary update validation failed' errors: errors
    ].
    
    [^database updateEmployee: anEmployee]
        on: Error
        do: [:ex | self signalDatabaseError: 'Failed to update employee' cause: ex]
</body>
<body package="EmployeeManagement-Service" selector="deleteEmployee:">
deleteEmployee: anEmployee
    | errors |
    errors := deleteValidator validateEmployeeForDeletion: anEmployee.
    errors isEmpty ifFalse: [
        ^self signalValidationError: 'Employee deletion failed' errors: errors
    ].
    
    [database deleteEmployee: anEmployee]
        on: Error
        do: [:ex | self signalDatabaseError: 'Failed to delete employee' cause: ex]
</body>
<body package="EmployeeManagement-Service" selector="deleteEmployeeById:">
deleteEmployeeById: anId
    | employee |
    employee := self readEmployee: anId.
    self deleteEmployee: employee.
</body>
<body package="EmployeeManagement-Service" selector="searchEmployeesByName:">
searchEmployeesByName: searchTerm
    | errors allEmployees |
    errors := readValidator validateSearchCriteria: searchTerm.
    errors isEmpty ifFalse: [
        ^self signalValidationError: 'Search validation failed' errors: errors
    ].
    
    allEmployees := self readAllEmployees.
    searchTerm ifNil: [^allEmployees].
    searchTerm isEmpty ifTrue: [^allEmployees].
    
    ^allEmployees select: [:emp | emp name includesSubstring: searchTerm caseSensitive: false]
</body>
<body package="EmployeeManagement-Service" selector="searchEmployeesByDepartment:">
searchEmployeesByDepartment: department
    | errors allEmployees |
    errors := readValidator validateDepartmentFilter: department.
    errors isEmpty ifFalse: [
        ^self signalValidationError: 'Department search validation failed' errors: errors
    ].
    
    allEmployees := self readAllEmployees.
    department ifNil: [^allEmployees].
    department isEmpty ifTrue: [^allEmployees].
    
    ^allEmployees select: [:emp | emp department = department]
</body>
<body package="EmployeeManagement-Service" selector="signalValidationError:errors:">
signalValidationError: message errors: errors
    | errorMessage |
    errorMessage := message, ': ', (errors joinSeparatedBy: '; ').
    ValidationError signal: errorMessage
</body>
<body package="EmployeeManagement-Service" selector="signalDatabaseError:cause:">
signalDatabaseError: message cause: exception
    | errorMessage |
    errorMessage := message, ': ', exception messageText.
    DatabaseError signal: errorMessage
</body>
<body package="EmployeeManagement-Service" selector="signalNotFoundError:">
signalNotFoundError: message
    NotFoundError signal: message
</body>
<body package="EmployeeManagement-Service" selector="EmployeeService class>>instance">
instance
    Instance ifNil: [Instance := self new].
    ^Instance
</body>
<body package="EmployeeManagement-Service" selector="EmployeeService class>>reset">
reset
    Instance := nil.
</body>
<body package="EmployeeManagement-Service" selector="EmployeeService class>>initialize">
initialize
    ValidationError := Error subclass: #ValidationError
        instanceVariableNames: ''
        classVariableNames: ''
        poolDictionaries: ''
        category: 'EmployeeManagement-Exceptions'.
    
    DatabaseError := Error subclass: #DatabaseError
        instanceVariableNames: ''
        classVariableNames: ''
        poolDictionaries: ''
        category: 'EmployeeManagement-Exceptions'.
    
    NotFoundError := Error subclass: #NotFoundError
        instanceVariableNames: ''
        classVariableNames: ''
        poolDictionaries: ''
        category: 'EmployeeManagement-Exceptions'.
</body>
</methods>
</class>
</st-source>
